* Scratch

  Здесь лежат куски текста, которым еще не нашлось место в основном
  тексте.

** Базовые определения

*** Ресурс

    Отдельная сущность, адресуемая уникальным идентификатором. Роль
    идентификатора выполняет URI.

    Имеет множество атрибутов в формате ключ=значение.

    Имеет множество представлений.

    Ресурс имеет класс, который определяет его базовый логический
    тип. Класс определяет какие атрибуты можно вешать на этот ресурс и
    с помощью каких представлений его рисовать.

    Идентификатор позволяет выцепить из источника данных настоящий
    контент, соответствующий ресурсу. Это так называемый dereferencing.

    Контент есть только у неделимых ресурсов, то есть на самом деле не
    у всех. Контент есть у ресурса, являющегося параграфом текста,
    картинкой, аудио-файлом, видео-файлом. Для ресурсов, у которых нет
    контента, устанавливается некий пустой адаптер.

*** Представление

    У ресурса есть класс. Классу соответствует множество представлений,
    из которого выбирается нужное. Представление – это шаблон, который
    получает на входе ресурс, достает из него хеш с атрибутами, с
    помощью адаптера получает контент и рисует из всего этого html.

    У одного ресурса есть множество представлений.

    Три стандартных, которые показывают ресурс вне зависимости от того
    есть у него класс или нет:

    1) ~default~ – показывает атрибуты и контент. Атрибуты содержащие
       ссылки на другие ресурсы показываются просто ссылками и никак не
       отображаются.
    2) ~inline~ – показывает только контент. Для параграфа это текст в
       теге ~<p>~, для картинки тег ~<img>~ и так далее.
    2) ~link~ – показывает только ссылку на ресурс.

    Расширенные, опирающиеся на класс:

    1) ~classed-link~ – отображает иконку рядом со ссылкой в зависимости
       от типа ресурса.
    2) ~card~ – показывает некоторую компактную summary по ресурсу и
       ссылку на полную версию. Например для книги это может быть
       обложка, под которой написано полное название и год
       издания. Карточки используются при отображении "плитки" из
       ресурсов.
    3) ~classed-link-with-card~ – ~classed-link~ у которой при навении
       мышки на ссылку появляется карточка во всплывающем окне.

*** Атрибут

    Атрибут тоже ресурс. На него тоже можно навешивать атрибуты.

    Адаптер для него HTTP, потому что так сложилось.

    Формат атрибута ~<attribute>=<value>~. UUID ресурса плюс ключ и значение
    образовывают триплет.

*** Адаптер

    URI состоит из NID и NSS.

    NID – namespace id. Позволяет выбрать адаптер для совершения с ресурсом базовых
    действий.

    NSS – namespace spicific string. Позволяет однозначно ссылаться на
    ресурс внутри определенного namespace.

    Основные действия, которые должен поддерживать ресурс:

    - создание
    - чтение
    - обновление
    - удаление

    Действия над метаданными внутри ресурса:

    - добавить единицу метаданных в формате ключ=значение
    - вернуть значение по определенному ключу
    - считать все метаданные и вернуть хеш
    - установить значение по определенному ключу
    - удалить единицу метаданных по ключу

    Некоторые ресурсы могут не поддерживать метаданные (plain text) или
    быть недоступными для удаления/редактирование (страница в
    интернете). В этом случае адаптер просто не поддерживает эти
    операции.

** Del.icio.us

   Старая заметка про [[https://delicious.com][delicious]]:

   #+BEGIN_QUOTE
       Про отношения с делишесом. Плохие у меня с делишесом
       отношения. Естественный подход мне не нравится. Точнее он у
       меня изначально вызвал какое-то непонимание. Поэтому изначально
       я пользовался противоестественным способом. Пытался добавлять
       избытычные метаданные. Сделал подобие онтологии. Но проблема
       этого подхода в том, что дальше с данными сделать ничего
       нельзя. Язык запросов лучше даже на френдфиде.

       Есть другая сторона. Почему фрф лучше для показывания
       ссылок. Сохранение ссылки очень мало кто сопровождает тем
       почему эта ссылка привлекла внимание. Никто не пишет эту самую
       пресловутую тысячу знаков. Это долго и никому не
       интересно. Сохранение ссылки – это тоже самое рассказывание
       истории. Потому что без истории ссылки никому не нужна. Этих
       ссылок вокруг слишком много, чтобы во все тыкать и самому
       разбираться что там к чему. Социальность делишеса проявляется
       только в одном случае – когда люди начинают искать популярные
       ссылки по какому-то тегу.

       Компенсировать отсутствие обсуждения заправлением делишеса во
       френдфид тоже плохо. Потому что если исходить из того, что это все
       ссылки "на потом", то соотношение сигнал/шум становится слишком
       низким. Каждый сохраняет в день по несколько ссылок умножить на
       количество френдов – получается жуткий мусор. Поэтому ссылки нужно
       обсуждать там, где они лежат.

       У делишеса есть проблема интерфейса – сохранять слишком долго. В
       результате на смену ему пришел Read It Later. Пост сохраняется
       одним нажатием галочки. Получается обычный линейный список. То,
       что прошло испытание временем переносится в делишес. Или про это
       рассказывается история во френфиде. Лишнее удаляется одним
       кликом.

       Получается, что делишес – это медленные коммуникации. Медленные
       именно из-за интерфейса, а не по сути. Из этого вытекает очевидное
       в принципе заключение, что пропускная способность интерфейса
       определяет суть сервиса. Если сделать медленный интерфейс для
       чата, то это будет уже форум. Если сделать быстрый
       интерфейс для форума, то получится фрифид.
   #+END_QUOTE


** Реляционный подход - две таблицы

   Все хранится в двух таблицах: одна для объектов, одна для
   свойств. Лучше всего про этот подход написал какой-то чувак с [[https://news.ycombinator.com/item?id=10326764][HN]]:

   #+BEGIN_QUOTE
       Having a completely abstracted database with one big
       table called "things" and another big table called "relationships"
       seems really attractive before you actually do it. Then it starts
       to suck.
   #+END_QUOTE

   Можно как оптимизацию добавить третью таблицу, которая позволяет
   хранить деревья, упорядоченные и не упорядоченные списки, не
   прибегая к упоротому способу ~rdf:next~.

   В таблице =Things= включен [[https://en.wikipedia.org/wiki/Single_Table_Inheritance][single-table inheritance]], который
   выгружает ресурсы в соответствующие класы в коде.

   Валидации делаются засчет того, что у ресурсов типа =Relationships= в
   классах есть методы в духе =domain= и =range=, которые возвращают
   множества того, что можно крепить к свойству слева и справа
   соответственно.

   Инферинг делается колбеками в коде:

   : after_create :add_inverse_property

   По-прежнему нужно много программировать, но есть и еще одно
   глобальное ограничение - все это будет сильно тормозить. Чтобы
   вытащить один логический кусок данных из базы, по этим двум
   таблицам нужно будет очень много ходить. Чтобы это заставить
   работать хоть сколько нибудь быстро нужны будут [[https://www.postgresqltutorial.com/postgresql-recursive-query/][рекурсивные
   запросы]]. Рекурсивные запросы -- это хорошо, но есть специальные
   базы, уже заточенные под хранение графа.

*** Конспект

    Сначала у нас есть один ресурс – книга. У него есть атрибут =content=
    в котором лежит ссылка на дерево.

    Ссылка на дерево – это указатель на анонимный корневой элемент
    дерева, к которому крепятся его элементы. У элемента дерева, помимо
    информации о вложенности есть только одна полезная нагрузка –
    ссылка на ресурс.

    Мы делаем первый запрос и получаем из ресурса класса ~Book~ ресурс
    класса ~Outline~.

    Мы делаем второй запрос и получаем свойство ~content~ ресурса класса
    ~Outline~. В нем хранится ссылка на дерево.

    Мы делаем третий запрос и получаем упорядоченный массив
    элементов дерева, потому что nested set. Ресурсы крепятся к
    элементам дерева с помощью ~includes~. Для этого нужен один ~join~.
    На выходе получаем массив элементов дерева, с уже загруженными из
    базы элементами типа ~Paragraph~, ~Section~ или ~List~.

*** Цитаты, разложенные по главам

    У цитаты есть функциональное свойство источник. Функциональное в
    том смысле, что оно у него может быть только одно, потому что у
    цитаты есть только один источник.

    Цитата крепится свойством ~source~ к элементу оглавления класса
    ~Section~. Оглавление в книге одно на всех. К нему крепятся и
    конспекты, и цитаты, и контент. Это означает, что элемент
    оглавления должен иметь свой тип и свои свойства, к которым
    крепятся соответствующие деревья.

    Допустим он имеет тип ~Section~. У ~Section~ есть четыре атрибута:
    ~dc:title~, ~my:content~, ~my:outlite~, ~my:quotes~.

    Первый запрос: взять у книги атрибут ~оглавление~ и достать оттуда
    ссылку на анонимный элемент дерева, который хранит все элементы
    оглавления класса ~Section~.

    : resource[toc] = tree_id

    Второй запрос: прийти в таблицу деревья и вытащить оттуда всех
    детей этого анонимного элемента, сделав на них ~inludes~, что дает
    нам все ресурсы описывающие главы. Это первый ~join~.

    : tocs = Tree.find(tree_id).descendants.includes(r)

    Третий запрос: из каждого ресурса типа ~Section~ надо достать
    свойство ~quotes~, которое ссылается на анонимный элемент дерева,
    который хранит список элементов класса ~Quote~, который нам и нужен.
