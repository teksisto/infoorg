#+TITLE: Infoorg
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/web.css">
#+LINK: wiki https://en.wikipedia.org/wiki/%s
#+OPTIONS: H:4

[[./images/pepe_silvia.png]]

* Про этот текст

  Этот текст про организацию информации и поиски подхода к реализации
  персонального информационного менеджера.

  У этого текста есть несколько задач:
    - дать человеку, который заинтересовался вопросом, хотя бы карту и
      ссылки на большие вещи, которые всплывали в обсуждениях вопроса;
    - показать направления решения задачи формата хранения информации,
      на которой все базируется, и которая больше всего тормозит
      процесс развития области;
    - попытаться выработать терминологию и общий язык при описании
      функциональности софта, который регулярно появляется;
    - поговорить про практики, которые стоят за инструментами, потому
      что инструменты создаются для обслуживание практик;
    - вписать вопросы инфоорга в контекст различной [[infoorg-professionals][профессиональной
      деятельности и образования]].

  Общая структура текста:
    - немного про [[infoorg-context][область инфоорга]] и зачем он;
    - мои [[i-want-to][практики под которые нет инструмента]];
    - мои идеи [[i-suggest-to][про концептуально-интерфейсные части инструмента]];
    - рассмотрение RDF как решения для пользовательских онтологий и [[storage-bottle-neck][задачи хранения]];
    - [[history][исторический кусок]] со ссылками на разное в области;
    - [[bookmarks][ссылки россыпью]].

  По адресу [[https://teksisto.github.io/infoorg/][teksisto.github.io/infoorg]] всегда лежит самая свежая
  версия. Исходники в формате org-mode лежат в [[https://github.com/teksisto/infoorg][репозитории]] на GitHub.

  Текст можно [[https://github.com/teksisto/infoorg/releases][скачать в формате epub]]. Сейчас я заливаю его руками, поэтому
  сейчас он обновляется где-то раз в несколько дней. Под это тоже [[https://github.com/teksisto/infoorg/issues/3][есть issue]].

  Ссылки маркируются иконками:
  - [[history][внутренняя ссылка]] показывается с иконкой "bring front";
  - [[https://en.wikipedia.org][ссылка на википедию]] (en);
  - [[https://freefeed.net][ссылка на freefeed]];
  - [[https://google.com][обычная ссылка]] показывается без иконки.

  Чтобы сослаться на раздел, надо скопировать ссылку из оглавления
  слева. Чтобы сослаться на какое-то конкретное место можно открыть
  [[https://github.com/teksisto/infoorg/blame/master/index.org][исходник в org-mode]] (это просто текст) и скопировать ссылку из
  номера строчки.

  Приходите обсуждать тему инфоорга в:
    - группу в FreeFeed - https://freefeed.net/infoorg (это такой формат
      между блогом и чатом)
    - канал в телеграме - https://t.me/infoorg

  Вы можете связаться со мной:
    - через телеграмм - https://t.me/teksisto
    - через гуглопочту ~teksisto~

  Все книги, на которые я ссылаюсь, можно скачать в [[wiki:Library_Genesis][библиотеке
  Genesis]]. Для книг обычно указано издательство, потому что для меня
  это маркер качества.

* Область инфоорга <<infoorg-context>>
** Контекст
*** Человек

    Это та часть, которая про стык психологии (не психотерапии) и
    нейрофизиологии.

    [[https://en.wikipedia.org/wiki/Memory][Человеческая память]] ограничена. Поэтому нужен инструмент который
    помогает забывать лишнее, вспоминать нужное и наводить порядок в
    голове. Автоматизация дает возможность выкинуть во внешнюю память
    то, в чем нет необходимости для принятия решения сейчас и освободить
    место для актуальной задачи.

    Человеческий [[https://en.wikipedia.org/wiki/Attention][фокус внимания]] ограничен. Переключения между разными
    инструментами подтачивают фокус и сбивают [[https://en.wikipedia.org/wiki/Flow_(psychology)][поток]].

    Время человека тоже ограничено. Тратить его на то, что можно
    автоматизировать бессмысленно.

    Весь танец инфоорга про то, как в ограниченный фокус внимания и
    ограниченную память запихать достаточно информации, чтобы можно
    было решить какую-то задачу.

    Если вам не хватает памяти или внимания, их можно прочекать. Есть
    информационная перегрузка, и стремление объять необъятное, а есть
    [[https://en.wikipedia.org/wiki/Attention_deficit_hyperactivity_disorder][ADHD]].

*** Психологические механизмы

    При написании следующего раздела, часто вспоминаю про якорение
    (что-то что помогает вспомнить о чем-то), тут должны быть еще
    какие-то эффекты. Это еще не практики, это то на чем они работают.

*** Практики

    Практик очень много, они вариативны и адаптируются каждым человеком
    под себя, в зависимости от личных и исторических особенностей.

    Можно выделять какие-то классы, но это огромная тема, сейчас я могу
    только перечислить что-то, чтобы было понятно о чем речь.

    Есть практики письма, и тут надо рассказывать чем бывает полезно
    записывать мысли, которые есть в голове. Есть текстовые практики,
    которые имеют более психотераепвтический характер, например
    ретроспектива прожитого отрезка времени.

    Есть устоявшиеся практики сохранения знаний в виде блогов, вики и
    что там еще бывает.

    Есть трекинг задач, to-do, задачи которые решаются как на личном
    уровне, так и на уровне организаций.

    Есть практики, нацеленные на обучение и исследование нового,
    например конспектирование.

    Есть [[https://en.wikipedia.org/wiki/Quantified_self][quantified self]], который позволяет следить за изменениями в
    организме (но не только) с помощью носимых устройств. Вообще
    пытается многие вещи сделать исчислимыми.

    Говоря про практики, я часто вспоминаю притчу, которую когда-то
    прочитал:

    #+BEGIN_QUOTE
      Ученик пришел к мастеру боевых искусств, который разработал свой
      стиль, и попросил научить его. Мастер ответил, что в юности он
      повредил колено, и он построил весь свой стиль на том, чтобы как
      меньше беспокоить больное колено, поэтому его стиль ученику не
      подойдет, и он не будет его этому учить. Но он может помочь ему
      выработать свой.
    #+END_QUOTE

*** Железо

    Под решение задач приходится выбирать железо. Приходится думать про
    десктопы, ноутбуки, мобильные устройства. Большие мониторы,
    маленькие мониторы, горизонтальные мониторы, вертикальные
    мониторы. Вопрос операционной системы тоже может быть решающим. Под
    давлением практик и софта железо меняется, но медленно.

*** Софт

    Софт нужен только для того, чтобы поддерживать какие-то
    практики. Иногда люди думают, что они продают инструменты, но на
    самом деле они продают практику. Иногда люди думают, что покупают
    инструменты, а на самом деле покупают практику.

    Софт уменьшает накладные расходы на реализацию практики. Практики
    не могут ждать, поэтому даже частично реализованный, софт приносит
    пользу.

    Практик огромное количество, они могут быть как мелкими, так и
    сильно энерго-затратными. Поэтому нет никакого решения для
    всех. Решением является инструмент для создания решений.

    Сейчас для реализации практики в софте нужны программисты, которые
    напишут код. Более гибкий софт и система хранения данных позволит
    большему количеству людей самим поддерживать свои практики.

** Многогранность <<infoorg-professionals>>

   Из контекста в котором существует инфоорг, который я описал выше,
   становится понятно, что это область многогранная и
   мультидисциплинарная.

   - психологи могут поделиться информацией о устройстве головы
     и психологических механизмах;
   - психотерапавты могут рассказать про практики и зачем они нужны;
   - математики могут рассказать как концептуализировать и
     представлять знания;
   - инженеры могут рассказать про софт и концепции его написания,
     начиная с [[https://en.wikipedia.org/wiki/Don%27t_repeat_yourself][DRY]];
   - библиотекари и музейщики могут рассказать про то, как
     упорядочивают большие коллекции;
   - людям, которые пилят искусственный интеллект, нужно как-то
     организовывать для него память;
   - переводчики могут рассказать про софт, автоматизирующий перевод;
   - книжные издатели могут рассказать про софт для паблишинга и
     верстку книг;
   - меломаны, фотографы и книголюбы хранят большие коллекции и как-то
     с ними обходятся;
   - люди ведут дневники, делают ретроспективы, адаптируют какие-то
     практики под себя;
   - бизнес может рассказать про инструменты и практики принятия
     решений, сохранения знаний и треккинга задач;
   - государствам, которым надо решать задачи типа единых
     классификаторов.

   Тут возможны несколько процессов обратного обогащения. С одной
   стороны люди, которые занимаются личными архивами, могут улучшить
   свои инструменты посмотрев в другие области. Так же они могут
   как-то привносить в окружение то, что они поняли, пока этим
   занимались. С другой стороны, те кто занимаются инфооргом на уровне
   бизнеса или государства могут улучшить свои практики и инструменты,
   посмотрев на тех, кто этим занимается академически, или притащив
   что-то из психотерании.

   Область инфоорга развилась настолько, что в ней есть даже
   [[education][образование]].

* Задачи инфоорга

  Сначала я выпишу задачи, которые решает система по хранению данных,
  чтобы потом можно было ссылаться на эти термины.

  Задачи инфоорга решаются последовательно. Если нет захвата, нечего
  идентифицировать. Если нет идентификации, не к чему привязывать
  классификацию.

  Каждый слой представляет абстракцию для других слоев.

  За основу этого списка был взят похожий из книги "Keeping found
  things found", но я переделал его под свои нужды.

** Хранение <<storage>>

   В каком формате хранить информацию из различных источников?

   Хочется унифицированности при которой не будет теряться информация.
   Данные должны забираться из источника целиком. Для этого нужна
   очень емкая структура для хранения.

   Например при переносе заметок из livejournal в wordpress может
   потеряться информация о текущей прослушиваемой музыке, которая есть
   в постах livejournal. Эта информация ничем особо не отличается от
   всей остальной – просто метаданные для поста. Тем не менее она
   теряется, поскольку в целевой системе нет такого поля.

   Есть ли импорт и экспорт из хранилища? Можно ли передвинуть данные
   куда-то еще? Сконвертировать в другой формат хранения?

   Я готов вбивать руками семантику на весь свой массив данных, но
   только при одном условии: чтобы мне больше никогда не приходилось
   это делать.

   Задача достаточно гибкого хранилища — это бутылочное горлышко,
   которое тормозит развитие инструментов, поэтому ей посвящен целый
   раздел [[storage-bottle-neck]["Задача хранения"]].

** Идентификация <<identification>>

   Как адресовать отдельный элемент в системе?

   Есть необходимость идентифицировать не только отдельные документы,
   но и части этих документов. В электронных книгах больше нет номеров
   страниц, что делать?

   Идентификация отделяет слой [[classification][классификации]] от слоя [[storage][хранения]]. После
   того, как элемент добавлен в систему, ему присваивается [[https://en.wikipedia.org/wiki/Universally_unique_identifier][UUID]] и
   классификация осуществлется уже над UUID. Нельзя классифицировать
   прямые пути в файловую систему или веб. Если файл перенести в
   другое место, или сайт переехал на новый домен, то метаданные,
   прикрепленные к этому файлу, будут ссылаться на пустое место.

   Системе должно быть безразлично не только что именно она
   описывает, но и где оно лежит. Хранение должно быть отделено от
   доступа.

** обавление данных <<capture>>

   Как данные попадают в систему?

   Захват должен сохранять контекст.

*** Импорт

    Настоящее и будущее связывает туннель и роют его с двух сторон. Из
    того, что нарыто со стороны будущего уже понятно, что некоторые вещи
    нужно делать прямо сейчас.

    Главное что нужно делать сейчас — готовить данные к импорту.

    Хранить данные в машинно-обрабатываемых форматах. Избавляться от
    бумаги. Оцифровывать все, что ценно.

    Избавляться от plain-text и прочих сырых форматов. Избавляться от
    форматов, которые не поддерживают метаданные. Избавляться от
    проприетарных закрытых форматов, которые не получится конвертировать
    и импортировать.

    Прописывать метаданные в том, что есть.

    Стараться не пользоваться сервисами, которые не отдают твои данные в
    структурированных форматах.

    Если все это делать, то можно проверять каждую из новых программ,
    которые периодически проверяются, путем написания конвертера и
    импорта, а не вбивать руками.

    Компьютер знает о нас очень много. Все что может быть
    импортировано автоматически должно захватываться автоматически.

*** Захват

    Первое упоминание в системе о существовании объекта. Часто люди не
    знают зачем сохраняют что-то. Упоминание объекта может быть только
    потенциально полезным. Если захват стоит ноль, значит сохранять
    надо все что почесало мозг. False positive keeping должен умереть.

    В случае, когда понятно зачем сохраняешь, например при добавлении
    to-do, все остается по-прежнему -- захват должен стоить ноль.

    Поэтому захват -- он больше про интерфейс. Интерфейс должен быть
    максимально быстрым, а значит простым.

    Задача захвата хорошо решена, проблемы начинаются когда
    инструменты для захвата начинают использоваться для например
    классификации, у одной команды не хватает ресурсов, чтобы хорошо
    сделать и то, и другое, а выпускать из своей экосистемы, отдав ему
    данные, пользователя не хотят.

**** Захват из "пространства"

     Например всякие to-do или упоминание чего-то в разговоре, что
     нужно потом как-то раскопать или почекать. В том числе для такого
     захвата отлично подходит бумага, как временное решение, потому
     что захват не про классификацию и упорядочивание. "Написать на
     клейком листочке" может быть отличной системой захвата, что не
     отменяет потом необходимости эти листочки переносить в какое-то
     более надежное и структурированное хранилище.

**** Захват из веба

     Самый простой тип захвата из веба -- поставить bookmark. Это
     первый, самый простой способ способ захвата. Пример почти
     идеального захвата -- [[https://app.getpocket.com/][Pocket]]. По-крайней мере, был раньше, когда
     при нажимании кнопки "сохранить" не появлялось дополнительное
     меню.

     Keeping is not organizing. Захват не предполагает, что
     захватываемое будет сразу упорядочиваться. Оно только закидывает в
     inbox "разобрать". Захват и классификация -- это разные задачи,
     они не обязательно должны выполнять одновременнно, но могут, если
     это приносит пользу.

     У этого типа захвата есть минус -- ссылки на больших периодах
     времени ненадежны, они [[https://en.wikipedia.org/wiki/Link_rot]["протухают"]]. В том числе поэтому были
     придуманы web clippers. Они сохраняют веб-документ частично или
     полностью, чтобы потом к нему можно было обратиться, когда доступ
     к исходному ресурсу невозможен.

     Захват должен сохранять контекст. Для web clipper самое логичное
     -- сохранить не только кусок документа, но и ссылку на него, дату
     сохранения и, возможно, историю браузера как пользователь добрался
     до этого документа. Чем больше, тем лучше. Для сохраненного файла,
     который упал в inbox "Downloads" все тоже самое -- дата, ссылка,
     откуда он взялся.

** Классификация <<classification>>

   Как описывать объекты хранящиеся в системе?

   [[https://en.wikipedia.org/wiki/Metadata][Метаданные]] и [[https://en.wikipedia.org/wiki/Ontology_(information_science)][онтологии]].

   Не все файлы нуждаются в семантике. Целая куча постоянно
   скачивается, просматривается и удаляется. Нет никакого смысла
   наводить на них семантику, кроме может быть примитивной
   машинной. Те файлы, которые должны быть упорядочены, должны лежать
   в упорядоченном хранилище. Все остальное пускай лежит как раньше.

** Структурирование <<structure>>

   В какие структуры объединяются ресурсы?

   Группировка и сортировка.

   Структура информации являются функцией от ее объема. Как только
   меняется объем, структуре приходится его догонять. В одной папке с
   10 файлами легко найти нужный, в одной папке с 1000 файлами уже не
   очень. С другой стороны, если эта 1000 файлов отсортирована по
   какому-то признаку, там снова можно ориентироваться.

   Сохраненные запросы / Деревья / Контексты

** Поиск <<search>>

   Как искать нужную информацию в массиве?

   #+BEGIN_QUOTE
       На больших объемах информации поиск итеративен и разные "мили"
       проходятся разными способами. Полнотекстовый поиск, сохраненные
       запросы и обычный иерархический подход будут мирно сосуществовать
       на машинах. (urbansheep)
   #+END_QUOTE

** Репрезентация <<representation>>

   Как отображать данные? Как нарисовать на экране все то, что мы
   сохранили. Задача делится на несколько уровней.

*** Как нарисовать один раз

    Это про обычный пользовательский интерфейс. Смотреть на байтики в
    hex-редакторе неудобно.

*** Как нарисовать множеством способов

    Одни и те же данные можно показывать в разном виде и рассматривать
    под разными углами. Можно показать граф картинкой, но можно и
    разложить в список.

    Можно создавать задачи в таск-трекере как обычно, проставляя связи
    "это сначала, это потом", но можно и показать в виде картинки
    графа, что очевидно даст совсем другой взгляд на ситуацию.

    Чтобы это сделать, хранение нужно выделять в слой. Если задачи
    нарисованы в графическом редакторе от руки, хранение будет
    совмещено с репрезентацией и отобразить это другим способом уже не
    получится автоматически.

*** Множество способов отображения текста <<representation-adaptive>>

    Это так же касается не только структур данных, которые отображают
    отношения между объектами, но и текста. Текст тоже можно показывать
    по-разному. Речь не про разное оформление (например "темная тема")
    и прочее accessibility, речь про структурные изменения.

    В частности, про вариативность гипертекста была придумана
    концепция [[https://en.wikipedia.org/wiki/Adaptive_hypermedia][adaptive hypermedia]]. Суть в том, что набор переходов с
    конкретной страницы может быть оптимизирован под
    пользователя. Проставлять ссылки и увеличивать общую связность
    хорошо, но далеко не всегда это нужно отображать, потому что у
    читающего постоянно будет съезжать фокус. Например в википедии на
    странице можно поставить очень много ссылок на связанные статьи,
    но это приведет к тому, что по каждой ссылке надо будет принимать
    решение — переходить по ней или нет.

    Совсем другая ситуация будет, если человек читает текст на другом
    языке. Тут единицей, которая может быть затруднением и требовать
    перехода, может стать любое слово.

** Интерфейс <<interface>>

   Если репрезентация занимается рисованием отдельного элемента в
   хранилище, то интерфейс это более глобальная задача, которая на
   репрезентации основывается.

** Аннотирование <<annotation>>

   Как хранить и связывать аннотации с сохраненными ресурсами?

   Как аннотировать текст?

   Как аннотировать аудио-файлы?

   Как аннотировать видео?

   Аннотирование в самом простом случае – это комментирование.

   Как аннотировать обновляющийся источник? Обновляющийся источник
   сложно аннотировать. Какие-то части появляются, какие-то
   пропадают. Последовательная нумерациия параграфов невозможна,
   потому что она будет ломаться каждую версию. Значит адресовать
   нужно по uuid.

   Удобство аннотирования – это аргумент в пользу блочной
   идентификации. Можно добавлять комментарии к каждому параграфу.

** Публикация

   Данные, накопленные и созданные в системе, нужно как-то показывать
   другим людям.

* Чего мне хочется от информационного менеджера <<i-suggest-to>>
** Пользовательские онтологии

   Возможность самому [[wiki:Conceptualization_(information_science)][концептуализировать]] и описывать объекты, которые
   хранятся в системе, без программирования и изменения схемы БД.

   Возможность самому создавать классы объектов и взаимосвязи между
   ними (например наследование).

   Возможность прямо из интерфейса системы накладывать ограничения и
   валидации на атрибуты.

   Возможность присваивать много одинаковых атрибутов одному и тому же
   объекту (например у произведения может быть несколько авторов).

   Возможность добавлять метаданные для метаданных (описание,
   человекочитаемые метки, свойства: транзитивность, inverseOf и
   прочее).

   Возможность класть в значение атрибута не только литералы (число,
   строка, дата), но и ссылки на другие ресурсы.

   Возможность автоматом проставлять обратные связи.

** Абстракция ресурса

   По сути я говорю про объединение базы данных и файлового менеджера.

   Есть куча данных, которая не представлена файлами. Письма, записи
   из он-лайн сервисов, метрики. Для всего этого лучше подходит формат
   базы данных. В файловой системе [[storage][хранение]] и [[classification][классификация]]
   объединены. Если отделить хранение от классификации, то можно
   объединять в одну ленту как виртуальные сущности, которые лежат в
   БД, как и реальные файлы, представленные в общем-то теми же самыми
   записями в БД.

   Для этого нужно ввести понятия ресурса, которое обозначает любую
   сущность в хранилище, как крупные и агрегированные, так и
   неделимые. В том числе ресурсом должны быть метаданные, потому что
   на них тоже надо как-то ссылаться и навешивать на них метаданные.

** Блочный текстовый редактор <<block-text-editor>>

   Любой текст, например книга, имеет структуру, которая сейчас
   представлена в основном неявно. Есть разделы, подразделы,
   параграфы, сноски. Эта структура может быть описана с помощью
   классов и отношений между ними, таким образом получится абстракция
   текста. Что идет за чем и что к чему может быть прикреплено, а что
   прикреплено быть не может.

   В HTML тоже есть некая концепция структура текста с правилами как
   она должна отображаться. [[http://w3schools-fa.ir/html/html5_new_elements.html][В HTML5 этого все больше]]. Так же в HTML
   есть понятие связанных документов через тег [[wiki:Link_relation][link]] (например
   следующий/предыдущий документ). В первом приближении, это
   предложение сделать все то, что сейчас в HTML называется [[https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements][блочными
   элементами]], отдельно хранимым и связанным метаданными. Каждый
   параграф, каждый список, элемент списка, каждую ячейку таблицы.

   Концептуализация текста может быть разной, она например одна у
   книги и другая у сценария.

   Блочный текстовый редактор управляется через концептуализацию
   текста, которая откладывается в пользовательской онтологии. Есть
   базовая концепция структуры текста -- есть главы, есть подглавы, в
   них параграфы.

   Но допустим пользователь хочет добавить в свое описание структуры
   текста новое поле -- [[https://en.wiktionary.org/wiki/side_note][side note]]. Он добавляет для параграфа новый
   атрибут sidenote в который кладет ссылку на другой ресурс класса
   текст. Потом надо поправить вьюшку для отображения и у параграфа
   появляется sidenote.

   Хорошая заметка Глеба Калинина [[http://glebkalinin.ru/content-management-vs-web-publishing/]["Контент-менеджмент и
   веб-публикации"]] описывает основы блочного текстового редактора.

   Блочный текстовый редактор позволяет делать [[https://www.mediawiki.org/wiki/Transclusion][transclusion]]. Добавлять
   внутрь текста какие-то сущности, которые хранятся и описываются
   отдельно, например цитаты или картинки. Если прийти в цитату
   отдельно и поправить опечатку, оно поправится везде, где цитата
   вставлена через translusion. Потому что хранится она отдельно.

   Удобство [[identification][идентификации]] – можно давать ссылку на конкретное место в
   тексте. Например цитаты – как пример производного ресурса – могут
   ссылаться на конкретное место, одкуда они были взяты. Возможность
   поставить ссылку на что угодно, начиная от параграфа и элемента
   списка до конкретной ячейки таблицы.

   Удобство [[classification][классификации]] – можно навешивать атрибуты на что угодно.

   Удобство [[annotation][аннотирования]] – к каждому параграфу можно добавить
   аннотацию, например комментарий.

   Удобство [[representation][репрезентации]] – разбивка на блочные элементы позволяет
   использовать разные движки для рендера. Например этот кусок написан
   textile'ом, тут нужна подсветка синтаксиса, а это описание графа на
   языке graphvis, которое нужно показать как картинку.

   Разбивка на блоки позволяет строить [[parallel-text][параллельные тексты]].

   Необязательно "что все это будет глючить и тормозить". Для
   отображения длинных текстов можно упреждающе кешировать рендер в
   целевой формат репрезентации. HMTL, который покажется пользователю,
   можно сгенерить один раз и показывать из кеша. Редактирование же
   всегда происходит на уровне отдельного элемента, например
   параграфа. Если получится после этого обновлять рендер частично,
   как например делается при билде софта с большой кодовой базой, то
   оно может работать.

   Еще примеры:
     - [[https://news.ycombinator.com/item?id=16823708][New York Times – Building a Text Editor for a Digital-First Newsroom]]

** Контексты и динамические деревья

*** Контекст

   Несмотря на то, что [[https://en.wikipedia.org/wiki/Tag_(metadata)][теги]] формально являются [[https://en.wikipedia.org/wiki/Metadata][метаданными]], хранить в
   них большинство форматов метаданных невозможно. У них нет для этого
   достаточной выразительной мощи, которую представляет
   [[https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model][entity–attribute–value model]]. По-прежнему появляются инструменты,
   которые предоставляют теги как единственный формат метаданных. Для
   меня это использование инструмента [[structure][структурирования]] для
   [[classification][классификации]], то есть не по назначению.

   Контекст — это развитие идеи тега. Это группировка, объединяющая
   ресурсы разного типа. У контекста есть человекочитаемый display
   name, поэтому больше не надо думать как извернуться, чтобы сделать
   тег уникальным. У контекста есть поле для описания.

   Контекст нужен для объединения ресурсов в одно целое и показывает
   хронологию развития какой-то темы. Контекст помогает показать как
   другой человек думает и как он пришел в текущую точку.

   Контекст по природе гетерогенен. Он может захватывать ресурсы
   любого класса. В одной ленте лежат ссылки, картинки, видео, книги
   или их главы, заметки и рабочие обобщения.

   На что это похоже:
   - на легковестный блог с вики-страницей в заголовке, в которой есть
     некое summary постов блога или объяснение зачем это все;
   - reddit – множество блогов, как на широкие темы, так и на очень
     обскурные, посты в которых появляются раз в год;
   - tumbler – множество блогов у одного пользователя;
   - redmine – страница версии. Там в заголовке вики-страница, а в
     хвосте автоматичекий список задач из спринта, разбитых по типу
     работ.

   Контекст состоит из:
   - название
   - заголовочный блок
   - фильтр, определяющий хвост
   - хвост = массив ресурсов

**** Заголовочный блок

     Заголовочный блок может использоваться как summary или описание
     того, зачем контекст нужен.

     Так же его можно использовать для агрегирования данных из
     элементов хвоста. Например контекст в который входят все
     поступления/расходы за месяц может показывать в заголовке график
     как менялась сумма денег в кошельке.

     Если контекст используется для создания категории постов, то есть
     как тег, то он дает некоторые преимущества. Маркер контекста может
     быть любым (хоть uuid). В то время как отображаться будет
     нормальное название. В головном блоке можно писать что здесь лежит
     и зачем.

**** Фильтр

     Запрос состоящий из атрибутов, их значений (больше/меньше,
     включение в диапазон, регулярки) и объединение этих фильтров по
     атрибутам с помощью конъюнкции, дизъюнкции и прочих операций над
     множествами.

**** Форма быстрого поста

     В контексте есть форма быстрого поста. Туда можно написать текст
     или закинуть файл. Атрибуты ему поставятся автоматически на
     основе фильтра.

**** Хвост

     Хвост определяется фильтром. Фильтр позволяет захватывать ресурсы в
     контекст автоматически. Например все заметки, которые ссылаются на
     конкретного человека.

     Контекст показывает хронологию развития какой-то темы. Контекст
     помогает показать как другой человек думает и как он пришел в
     текущую точку. Поэтому контекст должен уметь показывать хвост в
     прямом и обратном хронологическом порядках. Если я нахожу какой-то
     интересный блог в интернете, как правило, мне хочется читать его с
     начала.

     Если добавить сортировку по последнему обновлению, то, вы не
     поверите, но получится готовая структура для экспорта группы или
     пользователя в FreeFeed.

     В хвосте должна быть какая-то навигация, со всеми уже знакомыми
     инструментами: полнотекстовый поиск, [[https://en.wikipedia.org/wiki/Faceted_classification][фасетная классификация]] и
     сохраненные заросы. Чтобы прийдя в контекст, можно было например
     показать все видео или ресурсы другого типа, поискать текст или
     выполнить какую-то более сложную выборку.

*** Динамические деревья

    Контексты хорошо описывают то, что уже так или иначе происходит в
    вебе. Но множество вещей представлены файлами и с ними нужно
    как-то обходиться.

**** Проблемы иерархических файловых систем

    Главная проблема здесь в том, что [[storage][хранение]] при таком подходе
    совмещено с [[classification][классификацией]].

    Обычные файловые системы устроены иерархически. В зависимости от
    схемы классификации файл можно положить в разные папки. Проблемы
    начинаются когда:

    - один и тот же файл можно положить в разные места.
    - изменился объем информации и схему надо детализировать
    - изменился подход и классификацию надо переделывать

    Структура – это функция от объема информации. Меняется объем –
    меняется структура.

**** Замена одного дерево на множество

    Предложение в том, чтобы отделить хранение от классификации и
    создавать множество разных деревьев на основе запросов.

    На что это похоже: примеры такого уже давно есть в нормальных
    музыкальных плеерах, которые предлагают разнообразные способы
    отображения коллекции.

    Запрос мог бы выглядеть следующим образом:
    - на первом уровне выбери все ресурсы с определенным типом и
      сгруппируй по значению атрибута
    - на втором уровне каждую из получившихся груп сгруппируй по
      значению другого атрибута
    - и т.д.

**** Сохранение файловой семантики

     Необходимо каким-то образом отображать динамическое дерево в
     файловую систему, чтобы все имеющиеся приложения могли работать со
     структурой папок, которая генерится запросом.

     Обычная проблема каталогизаторов, например книжного каталогизатора
     [[tool-calibre][calibre]], в том, что доступ к структуре возможен только из
     интерфейса самого приложения. Нельзя пойти в папку,
     соответствующую ~категория/подкатегория/тег~ и открыть epub
     редактором.

     Мне известно про два инструмента, которые могут помочь для
     отображения динамического дерева в файловую систему и сохранения
     файловой семантики: [[https://en.wikipedia.org/wiki/Virtual_file_system][виртуальные файловой системы]] и [[https://en.wikipedia.org/wiki/WebDAV][WebDAV]].

     Если виртуальная файловая система позволяет ускорить отображение
     динамического дерева в файловую систему, то WebDAV позволяет
     монтировать ее удаленно, используя все плюшки и готовые
     инструменты, изготовленные для HTTP.

     Когда заходит речь про отображение в файловую систему часто
     вспоминают про [[https://en.wikipedia.org/wiki/Hard_link][hard links]]. Под Windows жесткие ссылки тоже есть,
     так что возможно это даже кросс-платформенное решение. Если бы
     речь шла только про файлы, это бы было отличное решение, но часть
     данных в системе файлами не представлена, поэтому hard links не
     подойдут.

     Ссылки:
     - виртуальная файловая система для Linux -- [[https://en.wikipedia.org/wiki/Filesystem_in_Userspace][FUSE]]
     - биндинги FUSE для ruby: [[https://github.com/lwoggardner/rfusefs][rbusefs]]
     - пример использования этих биндингов -- [[https://gist.github.com/teksisto/f35447da6e8079cfbe93][бесконечные рандомные pdf]]

*** Динамическое дерево как вложенные контексты

     Дерево вложенных контекстов – это и есть динамическое
     дерево. Запрос, который создает динамическое дерево создает
     вложенные контексты, фильтр каждого из которых формируется на
     основе запроса, генерирующего дерево.

     Новые сущности просеиваются сначала сквозь фильтр первого
     контекста, потом через фильтры вложенных контекстов и где-то
     оседают.

     Контекст гетерогенен. Ему без разницы что засасывать, потому что
     засасывает он ресурсы, адресуемые UUID. Поэтому ничто не мешает
     ему содержать в себе другие контексты.

     В этом случае заголовочный блок является элементом, отображаемым
     в ленте контекста верхнего уровня. Голова контекста – это обычный
     ресурс и у него, как и у любого другого ресурса могут быть разные
     вьюшки для отображения. Что позволяет ужать в графическом
     представлении весь контекст до заголовка со ссылкой.

*** Контекст есть у каждого ресурса

    Контекст есть у каждого ресурса. То есть есть как минимум какой-то
    контекст по-умолчанию в который входят:

    - все ресурсы, которые ссылаются на данный ([[https://en.wikipedia.org/wiki/Backlink][back links]]);
    - все ресурсы на которые ссылается он сам;
    - версии этого ресурса (как в смысле "версионность текста", так и
      в смысле "разные редакции/переводы одной книги").

    Дело в том, что ни жесткое дерево, ни запутанный граф сами по себе
    не подходят для хранения. Часть данных всегда упорядочена, часть
    связей всегда нарушает иерархию. То есть получается дерево,
    опутанное дополнительными связями между узлами. Это всевозможный
    cross-referencing, ассоциативные связи и прочее случайное, что
    может объединять узлы. Тот контекст, который есть у каждого узла
    – это в том числе те самые случайные связи.

*** Контекст как строительный блок интерфейса

    Получается, что контекст – это один из основных строительных
    блоков интерфейса.

    Любые коллекции (например список полученных/отправленных писем для
    человека) – это фильтр, который вытаскивает сущности из базы и
    показывает в головном блоке например статистику.

    Тут существует двойное использование контекста, которое долго не
    укладывалось у меня в голове. В смысле интерфейса контекст
    используется и для группировки и для отображения одного
    ресурса. Следите за руками.

    1) Человек заходит в контекст первого уровня. Если этот контекст
       не содержит других контекстов, то следующий прыжок будет в
       конкретный ресурс. Это шаг (3), но перед ним есть еще один.
    2) Если это вложенные контексты, то есть динамическое дерево, то
       переходя в каждый следующий контекст, пользователь по-прежнему
       использует интерфейс контекста для навигации в коллекции.
    3) Когда пользовататель открывает конкретный ресурс, тут контекст
       начинается использоваться в другом интерфейсном смысле.

    В заголовочном блоке отображается сам ресурс, а в хвосте все то,
    что ссылается на данный ресурс, все то, на что он ссылается и его
    версии. Фильтр тут более или менее одинаков для всех ресурсов (что
    не мешает его как-то тюнить).

*** Жизненный цикл контекст--ресурс

    У ресурса форма для быстрого поста начинает играть немного другую
    роль. Как только через нее добавляется ресурс, который не входит в
    дефолтный запрос, ресурс сам превращается в новый контекст,
    который отображается на верхнем уровне, там же, где отображается
    все остальные контексты. После этого его можно передвинуть
    куда-нибудь вглубь существующей структуры контекстов.

    Возможен и обратный процесс, поскольку контекст существует для
    концептуализации какой-то области, как только в головном блоке
    написан какой-то текст или нарисована какая-то диаграма, которая
    обобщает ресурсы из хвоста и контекст больше не планируется
    пополнять, контекст превращается в ресурс и "архивируется" или
    замораживается. Головной элемент должен условно говоря, сослаться
    на все элементы хвоста, чтобы "закрыться" и превратиться в
    ресурс. Часть элементов хвоста останется неиспользованными, что
    значит в рамках хвоста должно появиться свойство "было ли
    полезным, двигало ли тему" или осталось за бортом. Появляется две
    группы "полезное" и "безполеное". Наверное для "бесполезного"
    должен появиться сохраненный запрос "Корзина". Контекст
    закрывается, когда заголовочный блок сослался на все ресурсы из
    хвоста, помеченные как "полезные".

** Параллельные тексты <<parallel-text>>

   Под текстом здесь понимается любая информация, упорядоченная
   последовательно.

   Примеры параллельных текстов:

   - запись выступления и презентация
   - песня и ее текст
   - подкаст и трансрипт
   - фильм, аудио дорожки к нему и субтитры
   - цитата на двух языках
   - книга на двух языках

   Если параллелить две книги — это сложная задача, то запараллелить
   несколько переводов стихотворения или две цитаты – это вполне
   посильная задача даже для выполнения руками.

   Есть утилиты, которые строят параллельные тексты на разных языках
   автоматически. Например, параграф к параграфу. Как я предполагаю,
   они делают это на основе грубого машинного перевода и вычисления
   насколько параграфы идентичны.
   - [[http://www.abbyy.com/aligner/][Abbyy Aligner]]
   - [[http://www.supernova-soft.com/wpsite/products/text-aligner/create-parallel-text-for-language-lerning/][Supernova Aligner]]

   Ссылки:
   - [[https://en.wikipedia.org/wiki/Parallel_text][Parallel text]]
   - [[https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%82%D0%B5%D0%BA%D1%81%D1%82_(%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B8%D0%BA%D0%B0_%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)][Обучение через чтение параллельных текстов]]
   - [[https://www.w3.org/Submission/epub-a11y/#sec-mo][EPUB Accessibility 1.0 — Media Overlays Playback]]
   - [[https://stackoverflow.com/questions/51185543/how-git-similarity-index-is-calculated][How git similarity index is calculated?]]
   - [[https://support.gingerlabs.com/hc/en-us/articles/206060617-Recording-and-Playing-Audio][Notability]] пишет аудио параллельно вводимому от руки
   - [[http://ted.hyperland.com/myU/][Ted Nelson – My parallel universe]]

   [[https://freefeed.net/martian/32bca34f-a31e-40c2-816b-d997a7d07930][Пример запроса]] на параллельный текст аудио + книга.

** Ползучая автоматизация

   В системе нужны [[https://en.wikipedia.org/wiki/Hooking][хуки]], которые позволяют встроиться в жизненный цикл
   хранимого в системе. Для ресурсов это [[wiki:Create,_read,_update_and_delete][CRUD]] (создание, считывание,
   модицикация и удаление). Для метаданных это добавление и удаление
   единицы метаданных.

   Эти хуки позволят в том числе реализовать какие-то базовые куски
   функионала. Дальше будет несколько примеров как я это вижу.

*** Версионность

    Версионность включается навешиванием какого-то атрибута на ресурс,
    например текст (подразумевается текст в блочном редакторе). После
    выполнения update на ресурс (например параграф) в системе
    срабатывает создание нового параграфа, который слинкован с
    текущим, в котором хранится старый текст. Получается такой
    [[https://en.wikipedia.org/wiki/Copy-on-write][copy-on-write]].

*** Публикация

    После навешивание атрибута "опубликовано в системе X" на текст
    конвертируется в целевой формат и через API другой системы
    публикуется.

* Что бы я со всем этим делал <<i-want-to>>

  Речь идет про практики, которые я хотел бы внедрить, но у меня нет
  под них ни одного инструмента, ни набора инструментов, которые бы
  могли бы адекватно взаимодействовать. Все упирается в то, что если
  такого хочется, нужно переносить данные руками или писать
  конвертеры, что тоже не всегда возможно.

** Единый inbox

   Сейчас инбоксы разбросаны по разным местам: почта в клиенте, всякие
   read it later тулы для ссылок, rss-читалка, todo и задачи в
   таск-трекерах, бумажные стикеры, "посмотреть позже" в youtube и так
   далее. Если все это положить в одно место, то не надо будет
   переключаться и можно просто брать первый пункт и делать.

   Речь не про буквально "одну ленту", в ней конечно должно быть
   какое-то деление внутри, речь про один интерфейс к большому
   количеству вещей.

** Объединение классификаций

   По разным местам расползаются не только инбоксы, но и
   классификации, на youtube плейлисты, в букмарках теги, в соцсетях
   хештеги и так далее. Эти классификации имеют разную выразительную
   силу, что еще больше все запутывает.

   Но когда человек копает какую-то тему, у него неизбежно будут
   накапливаться разные типы ресурсов: книги, статьи, видео, аудио,
   картинки. Разбрасывать это по разным местам, а потом собирать в
   единую ленту в голове дорого. А если ты наблюдаешь за тем, как это
   делает другой человек, еще дороже. Потому что глобальная картина,
   что происходит в совокупности бункеров отдельных сервисов, есть
   только в голове у этого одного человека.

** Оглавления для источников

   Оглавление, внутренняя древовидная структура, бывает не только у
   книг. Есть варианты, когда оглавление появляется у видео и аудио,
   например [[https://matroska.org/technical/chapters.html][в формате mkv это chapters]]. Важно, что оглавления можно
   извлекать автоматом.

   Про книги. В идеале книги должны импортироваться внутрь, биться на
   блочные элементы и цитаты должны привязываться непосредственно к
   тому параграфу, откуда она была вытащена. Это сложная операция,
   даже если на входе epub. Поэтому делается упрощенный вариант: от
   книги оставляется скелет в виде оглавления.

   Иногда эта сложная операция может быть оправдана, если речь идет о
   работе переводчика. В этом случае речь идет про подготовку к
   изготовлению [[parallel-text][параллельного текста]].

   Речь про то, что должен быть выбор: либо источник создается без
   оглавления, либо есть оглавление, либо полный импорт.

   Оглавления нужны для последующей привязки к ним других элементов. К
   оглавлению можно крепить конспекты, события, цитаты, скриншоты
   (если это видео), новые термины или иностранные слова. У каждого из
   этих элементов остается обратная ссылка, откуда оно взялось, но так
   же их можно показывать с помощью других представлений. Например
   рисовать события из разных источников со своими оглавлениями на
   одном таймлайне.

   Как достать оглавление:
   - [[https://stackoverflow.com/questions/2431426/extract-toc-of-pdf][PDF]] (=mutool show file.pdf outline=)
   - [[http://www.idpf.org/accessibility/guidelines/content/nav/toc.php][EPUB]] (здесь это xml-файл, лежащий в архиве)
   - FictionBook (опять xml)

** Конспекты
   Конспект точно так же привязывается к оглавлению, как и
   цитаты.

   В итоге к оглавлению привязываются: сам текст с возможностью
   комментирования любого параграфа и отсылками к заметкам, цитаты,
   новые слова, события, ссылки, карточки персоналий.

** Цитатник

*** Привязка цитат к оглавлению книги

    Цитаты привязываются к оглавлению источника.

*** Заголовки для цитат

    Простая фича, но мне ее не хватает (например в tumbler). Обычно я
    делаю заголовки в формате "#{автор} про #{тема}".

*** Форматирование внутри цитат

    Чтобы подсвечивать болдом/цветом куски текста и
    вставлять/сохранять ссылки.

    Паттерн "куда смотреть".

*** Параллельные цитатники

    Параллельные цитатники позволяют отображать версии одной и той же
    цитаты на разных языках. Например чтобы сравнивать перевод и
    оригинал. Цитата по-прежнему является отдельной сущностью и
    крепится к оглавлению.

    [[https://htmlpreview.github.io/?https://github.com/teksisto/infoorg/blob/master/misc/parallel_quotes/quotes.html][Пример параллельного цитатника]] из книги Пирсига "Дзен и искусство
    ухода за мотоциклом". Поскольку не существует электронной версии
    перевода Горшкова я выписывал русские аналоги только для коротких
    цитат.

*** Колоды

    Колоды из цитат. Я называю это колодами, потому что когда-то
    печатал цитаты на карточках. Получалось что-то вроде карточной
    колоды. На самом деле это просто возможноть объединить
    произвольные цитаты в группу и добавить к ней описание.

*** Рифмы

    Если долго собирать цитаты между ними начинают проглядывать
    параллели. Есть мнение что люди часто говорят про одни и те же
    вещи, просто называют их по-разному. Хотелось бы помечать такие
    находки в цитатнике связями, а потом обсуждать и оценивать
    такие связи.

    Похожесть цитат не обязательно транизитивное свойство, но
    предполагаю, что для нескольких человек на относительно больших
    наборах цитат будут находится не только пары, но цепочки из цитат.

    #+BEGIN_QUOTE
        Reed College at that time offered perhaps the best calligraphy
        instruction in the country. Throughout the campus every poster,
        every label on every drawer, was beautifully hand
        calligraphed. Because I had dropped out and didn't have to take
        the normal classes, I decided to take a calligraphy class to learn
        how to do this. I learned about serif and san serif typefaces,
        about varying the amount of space between different letter
        combinations, about what makes great typography great. It was
        beautiful, historical, artistically subtle in a way that science
        can't capture, and I found it fascinating.

        None of this had even a hope of any practical application in my
        life. But ten years later, when we were designing the first Macintosh
        computer, it all came back to me. And we designed it all into the
        Mac. It was the first computer with beautiful typography. If I had
        never dropped in on that single course in college, the "Mac" would
        have never had multiple typefaces or proportionally spaced fonts. And
        since Windows just copied the Mac, it's likely that no personal
        computer would have them. If I had never dropped out, I would have
        never dropped in on that calligraphy class, and personal computers
        might not have the wonderful typography that they do. Of course it was
        impossible to connect the dots looking forward when I was in
        college. But it was very, very clear looking backwards 10 years later.
        Again, *you can't connect the dots looking forward*;
        you can only connect them looking backwards. So you have to trust that
        the dots will somehow connect in your future. You have to trust in
        something – your gut, destiny, life, karma, whatever – because
        believing that the dots will connect down the road will give you the
        confidence to follow your heart, even when it leads you off the
        well-worn path, and that will make all the difference.

        (Steve Jobs, [[http://www.americanrhetoric.com/speeches/stevejobsstanfordcommencement.htm][Commencement Address at Stanford University]])
    #+END_QUOTE

    #+BEGIN_QUOTE
        What you’re supposed to do in most freshman-rhetoric courses is to
        read a little essay or short story, discuss how the writer has done
        certain little things to achieve certain little effects, and then have
        the students write an imitative little essay or short story to see if
        they can do the same little things. He tried this over and over again
        but it never jelled. The students seldom achieved anything, as a
        result of this calculated mimicry, that was remotely close to the
        models he’d given them. More often their writing got worse. It seemed
        as though every rule he honestly tried to discover with them and learn
        with them was so full of exceptions and contradictions and
        qualifications and confusions that he wished he’d never come across
        the rule in the first place.

        A student would always ask how the rule would apply in a certain
        special circumstance. Phædrus would then have the choice of trying to
        fake through a made-up explanation of how it worked, or follow the
        selfless route and say what he really thought. And what he really
        thought was that *the rule was pasted on to the writing after
        the writing was all done*. It was post hoc, after the fact,
        instead of prior to the fact.

        (Robert M. Pirsig, [[http://design.caltech.edu/Misc/pirsig.html][Zen and the Art of Motorcycle Maintenance]])
    #+END_QUOTE

*** Компартментализм

    Термин из психологии. По-русски обычно переводят как "раздельное
    мышление". Типовые примеры из википедии: чудеса гуманизма в
    общественной деятельности, сочетающиеся с домашним насилием и
    жестокостью; борьба с порнографией, сочетающаяся с обширной
    домашней коллекцией порно.

    Если долго собирать цитаты, в них начинают появляться
    противоположные. Иногда один и тот же человек с течением времени
    высказывает противоположные взгляды (это нормально, он растет и
    меняется).

    Идея игры в том, что брать цитаты из разных мест и укладывать их в
    два столбика – за и против. Потом смотреть на то, как по любому
    вопросу есть две противоположных точки зрения, представленные
    вполне убедительными людьми. Может быть даже в три столбика: за,
    против и синтез – но попыток синтеза вокруг очень мало. Хотя идея
    "срединного пути" совсем не нова, и была озвучена как упоротыми
    изотериками, так и психотерапевтами.

    Я дошел до этой игры сам, но позже обнаружил, что уже есть сервис
    реализующий похожий подход – lovehate.ru. Там обитает много
    школьников, что конечно его портит.

    Играть в эту игру можно просто с самим собой, находя противоречия
    как в себе, так и в окружающем мире. Но есть и вторая цель –
    сделать какой-то аналог [[https://en.wikipedia.org/wiki/Debate#Student_debating_societies][дискуссионного клуба]]. Сбор best arguments,
    за и против какой-нибудь идеи.

    Конечная цель игры – синтез разных мнений.

    #+BEGIN_QUOTE
        Раздельное мышление — это защитный механизм,
        позволяющий человеку умещать в себе логически несовместимые
        установки. Если по каким-то причинам человек нуждается в каждой из
        своих несовместимых установок, то осознание возникающего
        противоречия начинает занимать мысли попытками это противоречие
        разрешить (зачастую с помощью рационализаций). Чтобы этого не
        происходило, человек может начать «раздельно мыслить» — не
        осознавая противоречия между ними, придерживаться всех
        несовместимых установок сразу. Со стороны это выглядит как простое
        лицемерие, но сам человек в этом случае придерживается своих
        установок вполне искренне, хотя и использует в каждом конкретном
        случае только одну из них.

        (Википедия, Мак-Вильямс)
    #+END_QUOTE

    #+BEGIN_QUOTE
        Настоящий спор, говорю тебе из лагерного опыта, производится
        как поединок. По согласию выбираем посредника – хоть Глеба
        сейчас позовем.  Берем лист бумаги, делим его отвесной чертой
        пополам. Наверху, через весь лист, пишем содержание
        спора. Затем, каждый на своей половине, предельно ясно и
        кратко, выражаем свою точку зрения на поставленный
        вопрос. Чтобы не было случайной ошибки в подборе слова –
        время на эту запись не ограничивается. [...] Пустые
        словопрения и сотрясения воздуха могут тянуться неделями. А
        спор на бумаге иногда кончается в десять минут: сразу же
        становится очевидно, что противники или говорят о совершенно
        разных вещах или ни в чем не расходятся. Когда же выявляется
        смысл продолжать спор – начинают поочередно записывать доводы
        на своих половинках листа.

        (Солженицин, "В круге первом")
    #+END_QUOTE

** События

   Я прочитал несколько книг про историю компьютеров и сетей и понял,
   к моменту прочтения последней, я уже не могу сопоставить даты,
   которые мне описывают сейчас, с датами, которые были описаны в
   предыдущих книгах. Было бы круто наложить последовательности
   событий друг на друга и показать это все на таймлайне.

   Проблема в том, что когда я слышу, что "Хоббит" был опубликован в
   1937 году, я уже давно забыл, что в том же году вышла первая
   диснеевская полнометражка. События, даты которых я слышу, для меня
   находятся в вакууме. Если их выписывать, то со временем контекста
   будет становится все больше.

   Так же это здорово прочищает мозг, потому что выясняется с какой
   легкостью я ошибаюсь на плюс-минус десять лет в интуитивной оценке,
   когда что-то произошло.

   Кое-как, но события сейчас реализованы. Их можно добавлять,
   разглядывать на таймлайне через [[http://visjs.org][vis.js]], и крепить вместе с цитатами
   к оглавлению книги.

   [[./images/timeline/timeline1.png]]

   GitHub - [[https://github.com/teksisto/timeline][teksisto/Timeline]]

** Словарь

*** Личный словарь терминов

    Карточки для терминов, встреченных в тексте. Крепятся к
    оглавлению. Автоматически генерируют ссылки на запрос в гугл и
    википедию.

*** Словарь иностранных слов

    NOTE: Это старый кусок текста. Когда я это писал еще не было
    сайтов в духе LinguaLeo и Skyeng, которые это как-то
    реализовывают. Но я давно на них не смотрел и сейчас не могу
    сказть, как это связано с тем, что ниже.

    Например берем субтитры на английском, тупо режем их на слова и
    удаляем всякий очевидный мусор. Прикручиваем [[wiki:WordNet][WordNet]]. Удаляем
    множественные числа, превосходные степени, глагольные формы,
    междометия, предлоги и местоимения. Считаем частотность. Находим
    самые частовстречающиеся 2000 слов ([[https://en.wikipedia.org/wiki/Basic_English]["core vocabulary"]]). Делаем
    интерфейс, в котором пользователь может отметить знает он это
    слово или не знает (там не надо думать, если сомневаешься,
    говоришь, что не знаешь). На вычитку 1000 слов у меня уходило
    меньше часа. Предположим, что средний словарный запас у
    англоговорящего 20-30k слов, у того кто учит язык – сильно
    меньше. За 10-20 часов систему можно научить всем словам, которые
    ты знаешь. По сравнению со временем обучения языку это очень мало.

    Ок, на выходе мы получили список слов. Что теперь с ним можно
    поделать?

    Во-первых, можно прогнать свежий текст через базу и найти слова,
    которых ты не знаешь. Если прикрутить [[https://github.com/louismullie/treat][treat]], то еще и с частью
    речи. Теперь можно автоматом генерить из них карточки для
    запоминания, в которых будет учитываться часть речи ("мне
    встречалось это слово как глагол, а тут оно как существительное"),
    автоматически добавляться пример в котором слово попалось и будет
    стоять ссылка на конретный источник, откуда слово взялось ("[[capture][захват]]
    должен сохранять контекст"). Это очень круто, потому что руками
    делать карточки вымораживает. Из упоротых идей: можно скриншот
    делать из видео, где это слово показыватеся.

    В третьих, можно показывать сам текст с уже подсвеченными словами,
    про которые ты не знаешь. На них можно сразу навешить ссылки в
    словари и кнопку "создать карточку". Это пример [[representation-adaptive][адаптивной
    репрезентации]].

    Во-вторых, можно оценивать лексическую сложность текста до
    прочтения.

    В-третьих, можно понимать какие слова учить первыми, потому что
    они чаще встречаются.

    На картинке синяя часть полоски – это базовая лексика, красная –
    слова, которые повторяются два и больше раз, и желтая – слова,
    которые встречаются в сериале один раз.

    [[./images/words/words.png]]

** Обогащение личного хранилица за счет открытых источников

   В вебе много данных, доступных в структурированных форматах. Это
   касается простых вещей, которые интересны для пользователя:
   метаданные о музыке, книгах, фильмах, сериалах. Широкий спектр
   понятий из википедии доступен через DBpedia. Упоминая человека,
   место, термин, книгу или что-то еще внутри системы я хочу показать,
   что я говорю именно об этом объекте, в его общепринятом и
   отложенном в коллективной памяти значении. Так же это позволяет
   получить получить уже готовый, описанный объект, с картинками и
   метаданными.

** Импорт данных из веб-сервисов

   О плохом сервисе никто не знает, хороший закроется через 10
   лет. Плохой сервис не отдает данные пользователям, хороший имеет
   выгрузку данных и API. Но что с ними делать, если он все равно
   закрылся? Интерфейс пропал. Что делать с несколькими
   экспортированными наборами данных, если хочется единую ленту?

   Примеры веб-сервисов, которые пытались делать единую ленту: Singly,
   Locker, Memolane, FriendFeed. В настоящий момент все закрыты.

   Помимо единой ленты есть еще проблема единых метаданных. Теги и
   прочие метаданные из разных сервисов тоже надо приводить к одному
   знаменателю.

   [[https://freefeed.net/n1313/bf416e8b-0655-4425-8b4a-ca3e81434250][Пример запроса]] на такое.

** Кросс-публикация

   Разнообразие плаформ для паблишинга нарушает связность. Конечная
   цель публикации в том, чтобы люди получали доступ к
   публикуемому. Если публикуется только в одном месте, какой-то части
   людей будет неудобно ходить в место, потому что для чтения они
   используют что-то другое.

   Поэтому, если хранить контент локально и настраивать постинг в
   разные места автоматом, достигается максимальный охват. Это удобно
   читателям, это удобно авторам.

   [[https://freefeed.net/karabatov/d65a8372-b782-4e04-ae15-2da72218b04c][Пример запроса]] на такое.

* Задача хранения <<storage-bottle-neck>>

   Здесь хранятся онтологии, метаданные и структурированные
   данные. Здесь же лежат [[block-text-editor][блочные тексты]], потому что они достаточно
   мелко нарезаны.

   "Физически" многие ресурсы хранятся все равно в файловой системе,
   базе или вебе. В базу они попадают как [[https://en.wikipedia.org/wiki/URL][URL]] (который "location on a
   computer network and a mechanism for retrieving it"). URL
   обслуживают какие-то хендлеры протоколов, но внутри системы это
   получает уникальный идентификатор и все дальнейшие манипуляции
   производятся с ним.

   Самое вменяемое решение, которое я вижу – это RDF. RDF хорошо
   решает задачи [[identification][идентификации]], [[storage][хранения]] и [[classification][классификации]], но
   продалбывает [[structure][структурирование]], самую решенную в мире
   проблему. Причем продалбывает намерянно и за сотни нефти, потому
   что исходит из [[open-world-assumtion][open world assumtion]].

   Сначала про него можно почитать в статье [[https://en.wikipedia.org/wiki/Resource_Description_Framework][RDF]] на википедии, а потом
   перейти к трем книжкам:

   - [[https://mitpress.mit.edu/books/semantic-web-primer-second-edition][A Semantic Web Primer (MIT Press)]]
   - [[https://www.elsevier.com/books/semantic-web-for-the-working-ontologist/allemang/978-0-12-385965-5][Semantic Web for the Working Ontologist (Morgan-Kaufman)]]
   - [[https://www.oreilly.com/library/view/learning-sparql-2nd/9781449371449/][Learning SPARQL (O'Reilly)]]

   Параллельно можно читать тексты в разделе [[https://www.w3.org/standards/semanticweb/][Semantic web]] на сайте
   W3C.

** Как это все может выглядеть на практике

   RDF – это идея, что данные хранятся в графе. Хранить этот граф и
   управлять им можно по-разному. Сразу можно сказать, что лучше всего
   хранить RDF в специально оптимизированном для этого хранилище —
   [[https://en.wikipedia.org/wiki/Triplestore][триплсторе]], но поскольку разговоры про другие варианты всплывают
   каждый раз, хочется зафиксировать что уже было расмотрено.

*** Реляционный подход - одна таблица под один тип ресурса

    Одна один тип ресурса, одна таблица. Вся локига лежит в коде. Под
    книги своя таблица, под аудио другая, под что-то еще третья. Чтобы
    всем этим управлять нужны программисты, это дорого. В целом это
    обычный подход сейчас. Под автоматизацию какой-то практики берут
    программиста, который делает инструмент.

    Самый плохой вариант этого подхода — когда метаданные являются
    столбцами в соответствующих таблицах. Схема становится еще более
    жесткой. Если вынести метаданные в единую таблицу, то мы приходим
    ко второму варианту — реляционный подход на двух таблицах.

*** Реляционный подход - две таблицы

    Все хранится в двух таблицах: одна для объектов, одна для
    свойств. Лучше всего про этот подход написал какой-то чувак с [[https://news.ycombinator.com/item?id=10326764][HN]]:

    #+BEGIN_QUOTE
        Having a completely abstracted database with one big
        table called "things" and another big table called "relationships"
        seems really attractive before you actually do it. Then it starts
        to suck.
    #+END_QUOTE

    Можно как оптимизацию добавить третью таблицу, которая позволяет
    хранить деревья, упорядоченные и не упорядоченные списки, не
    прибегая к упоротому способу ~rdf:next~.

    В таблице =Things= включен [[https://en.wikipedia.org/wiki/Single_Table_Inheritance][single-table inheritance]], который
    выгружает ресурсы в соответствующие класы в коде.

    Валидации делаются засчет того, что у ресурсов типа =Relationships= в
    классах есть методы в духе =domain= и =range=, которые возвращают
    множества того, что можно крепить к свойству слева и справа
    соответственно.

    Инферинг делается колбеками в коде:

    : after_create :add_inverse_property

    По-прежнему нужно много программировать, но есть и еще одно
    глобальное ограничение - все это будет сильно тормозить. Чтобы
    вытащить один логический кусок данных из базы, по этим двум
    таблицам нужно будет очень много ходить. Чтобы это заставить
    работать хоть сколько нибудь быстро нужны будут [[https://www.postgresqltutorial.com/postgresql-recursive-query/][рекурсивные
    запросы]]. Рекурсивные запросы — это хорошо, но есть специальные
    базы, уже заточенные под хранение графа.

*** Обычный реляционный подход + наведенная семантика

    Объекты каждого класса хранятся в отдельной таблице, связи между
    ними во внешних ключах. Связи лежат в коде. Новый класс – новый
    скаффолд. Ограничения разползаются в валидации и колбеки.

    На сервере стоит вордпресс, редмайн и медиавики. Делается точка
    доступа ~sparql~, которая маппит их таблицы в rdf и предоставляет
    унифицированный доступ. На основе этой точки доступа рисуется
    интерфейс.

    Основная проблема этого подхода в невозможности импорта данных из
    какого-то источника без изменения схемы хранения данных. Если схему
    не менять, то при импорте либо часть данных потеряется, либо
    придется менять их семантику. Например у нас есть хранилище,
    заточенное под wordress, а импортировать туда надо записи из
    livejournal, и поле "current mood" приходится класть прямо в текст
    записи, потому что мы не можем его добавить не программируя.

*** Графовая база данных

    Если конкретнее, то [[https://neo4j.com][neo4j]]. Про графовые базы пишут, что если
    цепочки связей между ресурсами больше двух, то можно использовать,
    а если нет, тогда postgres. То есть хранить там все нет смысла.

    Использует собственный язык запросов [[https://neo4j.com/docs/developer-manual/current/cypher/][Cypher]]. Говорят, что
    поддерживает SPARQL.

    Связи не являются узлами как в RDF. На них можно навешивать
    атрибуты, но это каждый раз происходит локально для каждой
    созданной связи. То есть метаинформацию кто и когда добавил связь
    оставить можно, но нельзя сказать, что эта связь соединяет только
    определенные узлы. Эта информация уходит в логику приложения.

    С другой стороны это радикально упрощает provenance. Нет этой
    упоротой rdf-схемы, где для описания одной связи надо использовать
    4+n триплетов, (n – количество триплетов с мета-информацией, 4 –
    statement + subject + predicate + object).

    Очень привлекают примеры с быстрой загрузкой данных из WordNet и
    dbpedia.

    Книга [[http://shop.oreilly.com/product/0636920041832.do][Graph Databases (O'Reilly)]] – это введение в neo4j.

    Обертка для ruby: [[https://github.com/neo4jrb/neo4j][neo4jrb]] ([[https://neo4jrb.readthedocs.io/en/7.1.x/][docs]] / [[https://www.youtube.com/watch?v=bDjbqRL9HcM][блог на neo4jrb за 10 минут]])

*** Семантика

    [[https://en.wikipedia.org/wiki/Triplestore][Триплстор]], [[https://en.wikipedia.org/wiki/Semantic_reasoner][ризонер]], запросы на [[https://en.wikipedia.org/wiki/SPARQL][SPARQL]]. Интерфейс на
    рельсах. Моделей нет. Контроллер по сути один –
    ~ResourcesController~. В основном надо рисовать партиалы для
    отрисовки ресурсов конретного класса с указанной детализаций и
    связанными ресурсами.

**** OpenLink Virtuoso

     На Virtuoso работает dbpedia.

     http://virtuoso.openlinksw.com/

**** Stardog

     https://www.stardog.com

     Платная.

     #+BEGIN_QUOTE
         It supports both semantic graphs, via RDF, SPARQL, and OWL, as
         well as property graphs via Apache TinkerPop and Gremlin–it's
         the *only graph database that supports both models over the same
         database, simultaneously*.

         – [[http://tinkerpop.apache.org/providers.html][Tinkertop doc]] / [[https://www.stardog.com/docs/#_property][Stardog doc]]
     #+END_QUOTE

     #+BEGIN_QUOTE
         Stardog supports integrity constraint validation as a data
         quality mechanism via *closed world* reasoning.

         – [[https://www.stardog.com/docs/#_validating_constraints][Stardog doc]]
     #+END_QUOTE

**** AllegroGraph

     http://franz.com/

     Выглядит вполне живым. Копирайт на сайте обновляется, есть всякие
     видео и список событий. Есть community версия и платная. Внезапно
     есть биндинги для Common Lisp и курсы по изучению Common Lisp.

** Декомпозиция

   RDF выглят перспективным и может использоваться для хранение. И для
   хранения нужно использовать триплстор. Теперь можно попробовать
   подумать, как разложить в него какие-то типичные практики.

*** Блог

   Представим себе блог, где каждый пост не является монолитом, а
   собирается из кусочков-атомов. Каждый атом имеет уникальный
   идентификатор, хранится отдельно и имеет свой набор
   атрибутов. Каждый параграф, картинка, видео-ролик в посте – это
   атом. Структура поста задается списком из уникальных идентификаторов
   каждого атома, каждый из которых трансклюдится в пост. На каждый
   параграф в посте можно сослаться, навесить атрибуты и добавить
   комментарии.

   Структура каждого комментария к посту повторяет его структуру. К
   этому добавляется древовидный или линейный контейнер, который хранит
   порядок комментариев.

   Посты организуются в хронологическое дерево. Это может быть
   стандартная схема год/месяц/день или какая-нибудь другая, например,
   год/неделя/день. Деревьев может быть несколько, выбор определяется
   удобством.

   Какие элементы структуры имеем в результате?

   - атомы с атрибутами
   - линейный список для объединения атомов в посты
   - комментарии, каждый из которых повторяет структуру поста
   - дерево для комментариев
   - посты организуются в хронологическое дерево

   Теперь отрезаем лишние сущности.

   Между атомом и постом нет никакой разницы. Оба имеют уникальный
   идентификатор и набор атрибутов. Разница только в том, что у поста
   есть сложный атрибут, который хранит список входящих в него
   атомов. Сущность, обладающую уникальным идентификатором, на которую
   можно навесить атрибуты я дальше буду называть ресурсом.

   Между деревом и линейным списком нет никакой разницы, поскольку
   дерево – это просто список списков. Дерево комментариев – это список
   списков, листьями которого являются ресурсы, содержащие комментарии.

   Теперь у нас есть два вида ресурсов: посты и комментарии. На самом
   деле, даже больше, потому что атомы тоже различаются – текст,
   картинка, видео. Поскольку у нас есть несколько типов ресурсов,
   логично ввести понятие тип ресурса. Определение ресурса расширяется
   до сущности, у которой есть уникальный идентификатор, атрибуты и
   тип. Тип – это такой же атрибут, как и дата создания, заголовок или
   любая другая мета-информация. Отличает его только то, что он
   является обязательным, поскольку без него мы не будем знать, как
   обрабатывать ресурс. Допустим, мы генерируем на основе нашей
   структуры html. Чтобы отобразить текстовый атом, надо преобразовать
   содержащуюся в нем разметку (например markdown) в html, обернуть
   это в div и отдать браузеру. Чтобы показать картинку, надо обернуть
   ее в тег img и отдать браузеру. Разница в обработке закрепляется в
   виде типа.

   Атрибуты — это, строго говоря, тоже ресурсы, а линейные списки
   создаются с помощью цепочек ресурсов, ссылающихся друг на друга. Так
   что кроме ресурсов ничего особо и не остается, но атрибуты и
   линейные списки мы выкидывать пока не будем, а то говорить не о чем
   будет.

   Итак, у нас остались:

   - ресурсы
   - атрибуты
   - линейные списки

   Переводим в термины rdf:

   - ресурс по-прежнему остается ресурсом (rdf:Resource)
   - атрибуты в терминологии rdf называются rdf:property
   - атрибут «тип ресурса» – это rdf:type
   - ресурсы, описывающие атрибуты, имеют rdf:type равным rdf:Property

   Схема получается довольно заманчивая, потому что в базе данных все
   поместится в две таблицы: одна для графа и одна для сопоставления
   идентификаторов атомов и все было бы хорошо, если бы речь шла про
   однопользовательскую систему, например, если бы мы говорили про
   гибкую структуру для бекапа различных блогов. Но у блога есть
   комментарии и пользователей много. Нужно разграничение
   доступа. Красивая схема «все в двух таблицах» разваливается. Права —
   зло, про них придется думать отдельно.

   Чтобы два раза не вставать, сразу скажу, что в смысле бекапа блог не
   сильно отличается от твиттера, френдфида, фликра и многого
   другого. Все упирается в модель безопастности.

*** Оценка количества триплетов при импорте книги

    На примере книги [[http://www.learningsparql.com/]["Learning SPARQL"]].

    Поиск блочных элементов:

    : cat OEBPS/*html > all
    : grep -cP '<img|<ol|<li[>\s]|<ul[>\s]|<p[>\s]|<pre[>\s]|<h\d[>\s]|<dd|<dt|<table|<tr|<td' all
    : => 2363 <1>

    Количество заголовков в оглавлении:

    : grep -cP '<a' bk01-toc.html
    : => 268

    Получается в среднем около 8 блочных элементов на элемент
    заголовка. Предположим, что большинство элементов прикреплены к
    заголовкам третьего уровня. (Уровень заголовка считается от единицы.)

    hasPart / isPartOf. Формула: ~2 * n * (d + 1)~ Каждый блочный элемент
    принадлежит своему заголовку и всем его родительским.

    : 2 * 2363 * (3 + 1) = 18904 <2>

    Теперь у нас есть количество элементов и есть связи. Надо какие-то
    индексы, чтобы сортировать части внутри заголовка. Придется
    использовать упоротую систему нумерации из rdf, где для описания
    связи двух элементов нужно три триплета.

    : (2363-1) * 3 = 7086 <3>

    С учетом того, что информация про язык, авторов и так далее не
    подвергается инференсингу, то в сумме получается:

    : 2363 + 18904 + 7086 = 28353

    30k триплетов на одну книгу. На 1k книг – 30 000 000 триплетов.


** Проблемы rdf
*** Open world assumption <<open-world-assumtion>>

    RDF разрабатывался для semantic web и основывается на [[https://en.wikipedia.org/wiki/Open-world_assumption][open world
    assumption]]. В нем многое сделано хорошо, но это мешает возможности
    хранения в нем жестко упорядоченных структур. Все контейнеры
    подрузамевают, что между элементами могут быть еще какие-то другие
    элементы, о которых мы не знаем.

    Некоторые триплсторы, в частности Stardog пытаются, в closed world
    assumption. Текущим рабочим обобщением для меня является то, что в
    рамках RDF, под какой-то имеющийся триплстор, за некоторое
    количество денег, можно реализовать нормальные упорядоченные
    контейнеры, а потом строить систему на них.

*** Отсутствие модели безопастности

    RDF предназначался для свободного доступа к информации через
    публикацию в веб. Поэтому модель безопастности у него строится
    где-то на уровне базы данных, а внутри можно читать
    все. Коммерческие триплсторы это как-то пересматривают, допустим
    можно только читать, но не писать. Но гранулированного доступа
    нет.

    В рамках персонального информационного менеджера это не проблема,
    потому что все данные пренадлежат одному пользователю и делать он
    с ними может все что угодно. На уровне групп и организаций будут
    возникать проблемы.

* История <<history>>
** (1945) Vannevar Bush — As We May Think

   [[https://en.wikipedia.org/wiki/Memex][Memex]]

   The Atlantic -- [[http://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/][As We May Think]]
   Life Magazine -- [[http://worrydream.com/refs/Bush%20-%20As%20We%20May%20Think%20(Life%20Magazine%209-10-1945).pdf][As We May Think]]

** (1967) Andries van Dam, Ted Nelson — Hypertext Editing System

   [[https://en.wikipedia.org/wiki/Hypertext_Editing_System][HES]]

** (1968) Douglas Engelbart — oN-Line System

   Энгельбарт известен как создатель компьютерной мыши. Но за всем
   этим стоит гораздо больше. Он не только придумал концепцию про
   augmenting human intellect, но активно реализовывал ее. Его демо
   NLS, которое называют "The mother of All Demos" в 1968, когда еще в
   области компьютеров для людей не было ничего, оказало огромное
   влияние на отрасль.

   [[https://en.wikipedia.org/wiki/The_Mother_of_All_Demos][The Mother of All Demos]] / [[https://en.wikipedia.org/wiki/NLS_(computer_system)][oN-Line System]]

   Видео: http://www.1968demo.org/

** (1968) Andries van Dam — File Retrieval and Editing System

   [[https://en.wikipedia.org/wiki/Hypertext_Editing_System][FRESS]]

** (1985) Intermedia

   [[https://en.wikipedia.org/wiki/Intermedia_(hypertext)][Intermedia]]

   #+BEGIN_QUOTE
       In 1983 Andries van Dam, William S. Shipp and Norman Meyrowitz founded
       the Institute for Research in Information and Scholarship (IRIS) at Brown.
       Their most notable project was Intermedia, a networked, shared, multiuser
       hypermedia system explicitly designed for use within university research and
       teaching environments. Intermedia was started in 1985 and sponsored by the
       Annenberg/CPB project and IBM (Meyrowitz 1986, 196).
   #+END_QUOTE

** (1982) Ted Nelson — Literary Machines

   #+BEGIN_QUOTE
     [[https://en.wikipedia.org/wiki/Ted_Nelson][Ted Nelson]] coined the term [[https://www.mediawiki.org/wiki/Transclusion]["transclusion"]], as well as [[https://en.wikipedia.org/wiki/hypertext]["hypertext"]]
     and [[https://en.wikipedia.org/wiki/hypermedia]["hypermedia"]], in his 1982 book [[https://en.wikipedia.org/wiki/Literary_Machines][Literary Machines]].
   #+END_QUOTE

** (1987) HyperCard

   #+BEGIN_QUOTE
       HyperCard is a software application and development kit for
       Apple Macintosh and Apple IIGS computers. It is among the first
       successful hypermedia systems predating the World Wide
       Web. HyperCard combines a flat-file database with a graphical,
       flexible, user-modifiable interface.
   #+END_QUOTE

   С HyperCard связано много историй, можно просто [[https://www.google.com/search?q=hypercard][открывать гугл]] и
   читать.

   [[https://en.wikipedia.org/wiki/HyperCard][Wiki]]

   [[https://vintageapple.org/macprogramming/pdf/HyperCard_Users_Guide_1987.pdf][HyperCard User Manual (1987)]]

** (1991) David Gifford — Semantic file systems

   Если коротко, то это [[https://en.wikipedia.org/wiki/Virtual_file_system][виртуальная файловая система]], в которой для
   документов добавляются атрибуты. Инкрементный поиск по ней выглядит
   так:

   : ls /some/root/${property}
   : => array of all property values
   : ls /some/root/${property}/${value}/
   : => all documents with property=value
   : => all properties, except used
   : ls /some/root/${property0}/${value0}/${property1}/${property1} ...
   : => all documents with property0=value0 & property1=value1
   : => all other properties, except property0 and property1

   Инкрементный поиск — сложная штука, если количество полей и их
   значений увеличивается. Но, видимо, можно делать сохраненные
   запросы с помощью символических ссылок.

   [[http://web.mit.edu/6.826/archive/S97/13-Gifford-Semantic-file-systems-paper.pdf][Paper]]

** (1993) LDAP

   LDAP интересен своей способностью строить классицификаторы. Там
   есть классы, наследование, всякие прочие штуки. Для 1993 года
   неплохо.

   [[https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol][LDAP]]

   [[http://www.zytrax.com/books/ldap/][LDAP for Rocket Scientists]]

** (1996) Eric Freeman and David Gelertner — Lifestreams

   [[https://en.wikipedia.org/wiki/Lifestreaming][Lifestreaming]]

** (1999) Presto

   Paul Dourish, W. Keith Edwards, Anthony LaMarca and Michael
   Salisbury. Xerox Palo Alto Research Center.

   [[http://www.dourish.com/publications/1999/tochi-presto.pdf][Presto: An Experimental Architecture for Fluid Interactive Document Spaces]]

** (2000) id3v2.4

   Informal standard на теги для mp3 файлов. Не смотря на то, что
   структура метаданных хорошо прописана, по большому счету ее никто
   не использует.

   Проблема метаданных для музыки – обширная тема, надо ее чуть позже
   раскрыть.

   http://id3.org/id3v2.4.0-frames

** (2000) MusicBrainz

   Хорошо прописанная [[classification][онтология]] для музыки, и описания альбомов на
   основе это онтологии.

   Есть их же [[https://picard.musicbrainz.org/][тулза]], которая умеет как Shazam опозновать трек и прописывать
   в него метаденные из их базы.

   [[https://musicbrainz.org][musicbrainz.org]]

** (2001) Eric Kim — Purple

   Подход к решению проблемы идентификации частей документа. Добавляет
   для блочных элементов в html якоря со ссылками. Реализация идеи Нельсона.

   https://en.wikipedia.org/wiki/Purple_Numbers

** (2002) Last.fm

   Скроблинг как решение задачи [[capture][захвата]] прослушиваемой
   музыки. Забирает информацию о треках и исполнителях из MusicBrainz.

   [[https://en.wikipedia.org/wiki/Last.fm][Last.fm]]

** (2001) Tim Berners-Lee — Semantic Web

   Статья создателя WWW о новом вебе, где данные представлены в виде
   структурированных датасетов. С помощью запросов из разных
   источников, данные можно обогащать подробностями.

   Tim Berners-Lee, James Hendler and Ora Lassila, "The Semantic Web",
   Scientific American, May 2001, p. 29-37.

   Как это выглядит сейчас - [[https://www.w3.org/standards/semanticweb/][W3C / Semantic Web]]

   [[https://en.wikipedia.org/wiki/Semantic_Web][Semantic web]]

** (2001) Tinderbox

   По сути – mindmap. Есть заметки, у них есть классы (прототипы на
   местном сленге) и атрибуты. Из классов можно делать иерархии.

   Есть несколько способов отображения заметок: mindmap (с
   возможностью заныривания в поддерево), timeline, outline, карта. В
   смысле отображение Tinderbox хорош, хотя он упускает один важный
   способ отображения – лента.

   Между заметками можно делать связи. Связи можно делать между любыми
   заметками, даже если они находятся на разных уровнях иерархии. Есть
   инспектор, который показывает все входящие и исходящие связи для
   конкретной заметки.

   Tinderbox не является редактором гипертекста (и тем более блочным
   редактором), связи у него существуют только на уровне
   заметок. Метаданные тоже можно навешивать только на уровне
   заметок. Текст по-прежнему лежит одним куском.

   Книга: [[http://www.markbernstein.org/][Mark Bernstein]] – [[http://www.eastgate.com/Tinderbox/TinderboxWay.html][The Tinderbox Way]]

   Сайт разработчика: [[http://www.markbernstein.org/][Mark Bernstein]] (MacOS only)

   [[https://en.wikipedia.org/wiki/Tinderbox_%28application_software%29][Tinderbox]]

** (2003) Joshua Schachter — Del.icio.us

   Социальные закладки. Можно группировать закладки с помощью тегов,
   теги можно объединять в групы. Возможен инкрементный поиск: после
   выбора тега показывается облако всех тегов, которыми еще потеганы
   данные закладки. Из него можно выбрать следующий тег и найти все
   закладки, которые потеганы обоими и новое облако оставшихся тегов
   для дальнейшего сужения поиска.

** (2003) Carsten Dominik — Org-mode

   Outliner для emacs. Выяснилось, что пока нет хорошего инструмента,
   которому можно доверять, вполне можно жить с помощью текстовых
   файлов и git.

   http://orgmode.org/

** (2005) Microformats

   Микроформаты - это про то, как разметить существующий HTML, чтобы
   можно оттуда было машинно извлечь данные. Например есть микроформат
   hCard, который позволяет выцепить из страницы контакты
   человека и импортировать их к себе. Верстка при этом не меняется.

   [[https://en.wikipedia.org/wiki/Microformat][Microformat]]
   Official site - [[https://microformats.org][microformats.org]]

** (2006) Calibre <<tool-calibre>>

   Книжный каталогизатор и конвервер.

   [[https://manual.calibre-ebook.com/viewer.html#navigating-around-an-e-book][Reference-mode]] в читалке. Решение проблемы идентификации для
   электронных книг.

   https://calibre-ebook.com/

** (2004) W3C — RDF / RDFS / OWL

   Идея Semantic web, о которой написал Тим Бернерс-Ли, выразилась в
   том, что W3C начал работу по выработке стандартов. В 2004 вышли
   первые версии ключевых стандартов, описывающих в первую очередь
   хранение данных.

   Книги:
     - [[https://mitpress.mit.edu/books/semantic-web-primer-third-edition][A Semantic Web Primer (MIT Press)]]
     - [[https://www.oreilly.com/library/view/semantic-web-for/9780123859655/][Semantic Web for the Working Ontologist (Morgan-Kaufman)]]

** (2004) Markdown

   Появление формата, который потом станет языком разметки для многих
   PIM.

   [[https://en.wikipedia.org/wiki/Markdown][Markdown]]

** (2007) EPUB

   Формат электронных публикаций. Основной открытый формат книг,
   который придет на смену PDF. В нем слои репрезентации и хранения не
   объединены как в PDF, поэтому он лучше приспособлен для обработки.

   [[https://en.wikipedia.org/wiki/EPUB][EPUB]]

** (2007) William Jones — Keeping Found Things Found

   Проект, развивавшийся в рамках [[https://ischool.uw.edu/][Information school]] Вашингтонского
   университета, продолжался с [[https://kftf.ischool.washington.edu/olderNews.htm][2006 по 2008]]. 2007 — год публикования
   книги. Книга посвященна в первую очередь personal information
   management. Сайт у них так себе, а вот книжка хорошая.

   [[http://www.keepingfoundthingsfound.com/][Official site]]

** (2007) DBpedia

   Вытаскивает структурированные данные из википедии, конвертит их в
   RDF, позволяет делать запросы на SPARQL.

   [[https://en.wikipedia.org/wiki/DBpedia][DBpedia]]

** (2007) Scrivener

   Инструмент для написания текстов. Есть текстовый редактор и
   контроль версий. Есть хранилище связанных файлов и их отображение в
   виде доски. Какие-то инструменты для рефакторинга в духе
   "переименовать персонажа".

   Надо еще в нем покопаться, но пока ощущение что в целом он про текст
   как проект.

   http://www.literatureandlatte.com/scrivener.html (MacOS only)

** (2007) Friendfeed

   Помимо всего прочего умел собирать данных из разных источников в
   одну ленту.

** (2008) SPARQL

   Язык запросов для датасетов на RDF дорос до того, что стал
   "official W3C Recommendation".

   [[https://en.wikipedia.org/wiki/SPARQL][SPARQL]]

   Книга - [[https://www.oreilly.com/library/view/learning-sparql-2nd/9781449371449/][Learning SPARQL (O'Reilly)]]

** (2008) Evernote

   Подкаст с Пачиковым: [[http://runetologia.podfm.ru/96/][Рунетология 45]]

   [[https://en.wikipedia.org/wiki/Evernote][Evernote]]

** (2009) Fluidinfo

   У них очень прикольный [[http://blogs.fluidinfo.com/][блог]], если читать его с начала, а не с конца.

   http://fluidinfo.com

   [[http://shop.oreilly.com/product/0636920020738.do][Getting Started with Fluidinfo (O'Reilly)]]

** (2009) CommonTag

   Теги на основе заголовков статей в википедии. Позволяют получить
   для тега хорошо прописанную семантику, в том числе на разных
   языках. Какая-то инкарнация этой идеи вроде используется в facebook
   для отмечания интересов пользователя. Фолксономии как-то не очень
   работают, давайте попробуем добавить тегам нормально прописанное
   значение.

   #+BEGIN_QUOTE
     CommonTag was a short-lived attempt in 2009 by Yahoo
     and others to create "an open tagging format developed to make
     content more connected, discoverable and engaging".
   #+END_QUOTE

   http://microformats.org/wiki/CommonTag

** (2010) Chandler

   [[https://en.wikipedia.org/wiki/Chandler_(software)][Wiki]] / [[http://chandlerproject.org/][Official site]]

** (2011) Smallest Federated Wiki

   Создатель первой вики, [[https://en.wikipedia.org/wiki/Ward_Cunningham][Ward Cunningham]], делает федеративную
   вики. Страницы можно форкать и поддерживать локально свою версию.

   http://fed.wiki.org

** (2013) Ginko

   Хороший. Умеет делать презентации и возвращать текст в виде
   json. Интересен в первую очередь интерфейсом.

   https://gingkoapp.com

** (2016?) Bear

   [[https://bear.app/][Site]]

** (2018) Notion

   [[https://en.wikipedia.org/wiki/Notion_(app)][Notion (app)]]

** (2019) Trilium notes

   Open source. Linux, Windows, может работать как
   веб-сервер на linux.

   Написан на JS. Данные хранит в sqlite.

   Умеет атрибуты для заметок. Значением атрибута может быть не только
   литерал, но и ссылка на страницу. Умеет типы связей и inverseOf.

   Ссылки, link map, беклинки.

   Нет кликабельных тегов, только поиск.

   Импорт и экспорт в markdown. Умеет шаблоны заметок и формочки на их
   основе. Умеет дерево и [[https://github.com/zadam/trilium/wiki/Cloning-notes][доступность заметки по нескольким путям]].

   Есть "ползучая автоматизация". Там куски кода на JS first-class
   citizen и лежат прямо в том же дереве.

   Интерфейс вкладочный, тайлового менеджера нет.

   Произвольные атрибуты, доступность заметки по множеству путей.

   GitHub - [[https://github.com/zadam/trilium][Trillium]]

   [[https://news.ycombinator.com/item?id=18840990][Hacker News thread]]

** (2020) Obsidian.md
** Locker

   Метасервис по собиранию данных из разных веб-сервисов в единую
   ленту.

** Singly

   Метасервис по собиранию данных из разных веб-сервисов в единую
   ленту. Singly ориентирован не только на собирание, но и на
   предоставление к собранному API для различных манипуляций и
   визуализации.

   #+BEGIN_QUOTE
      Singly was founded by Jeremie Miller, creator of XMPP, Jason Cavnar
      and Simon Murtha-Smith. Matt Zimmerman, former CTO of Ubuntu,
      joined Singly and was the CTO.
   #+END_QUOTE

   2013-08-22 – поглощен компанией [[http://appcelerator.com/][appcelerator]].

** NEPOMUK

   https://en.wikipedia.org/wiki/NEPOMUK_%28framework%29

** TiddlyWiki

   http://tiddlywiki.com/

* Ссылки <<bookmarks>>
** FreeFeed

   Группы:
   - [[https://freefeed.net/infoorg][@infoorg]]
   - [[https://freefeed.net/rdf][@rdf]]
   - [[https://freefeed.net/textools][@textools]]

   Теги:
   - [[https://freefeed.net/search?qs=%23infoorg][#infoorg]]
   - [[https://freefeed.net/search?qs=%23properinquiry][#properinquiry]]

** urbansheep

*** Pinboard

    - [[https://pinboard.in/u:urbansheep/t:km/][KM]] / [[https://pinboard.in/u:urbansheep/t:knowledgemanagement/][knowledgemanagement]]
    - [[https://pinboard.in/u:urbansheep/t:infoorg/][infoorg]]
    - [[https://pinboard.in/u:urbansheep/t:hypertext/][hypertext]]
    - [[https://pinboard.in/u:urbansheep/t:semanticweb/][semanticweb]]
    - [[https://pinboard.in/u:urbansheep/t:classification/][classification]]
    - [[https://pinboard.in/u:urbansheep/t:metadata/][metadata]]

*** FriendFeed

    - [[http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/infoorg.html][инфоорг]]
    - [[http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/svoy_nebolshoy_internet.html][свой небольшой интернет]]
    - [[http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/tsifrovaya_istoriya.html][цифровая история]]
    - [[http://urbansheep.com/friendfeed/urbansheep/lists/hashtags/arhivisty.html][архивисты]]

*** LiveJournal

    Сейчас ссылки на эти теги не работают. Сервис [[https://utx.ambience.ru/][UTX]], который
    использовался как замена тегам в ЖЖ, перестал работать и как
    находить эти записи непонятно.

    - [[https://urbansheep.livejournal.com/tag/info organization][info organization]]
    - [[https://urbansheep.livejournal.com/tag/classification][classification]]
    - [[https://urbansheep.livejournal.com/tag/memory_management][memory management]]
    - [[https://urbansheep.livejournal.com/tag/knowledge_management][knowledge management]]
    - [[https://urbansheep.livejournal.com/tag/hypertext][hypertext]]

** Учебные заведения <<education>>

   Вы только посмотрите на required readings в учебной программе
   Беркли. Где-то мы многое из этого уже видели.

   [[http://www.ischool.berkeley.edu/][UC Berkeley School of Information]]
   - [[https://bcourses.berkeley.edu/courses/1247347/assignments/syllabus][INFO202: Information Organization and Retrieval (Fall 2014)]]

   [[https://ischool.uw.edu/][University of Washington Information School]]
   - [[http://kftf.ischool.washington.edu/][Keeping Found Things Found]]

** Термины

   - [[https://en.wikipedia.org/wiki/Information_science][Information science]]
   - [[https://en.wikipedia.org/wiki/Conceptualization_(information_science)][Conceptualization (information science)]]
   - [[https://en.wikipedia.org/wiki/Personal_information_manager][Personal information manager]]
   - [[https://en.wikipedia.org/wiki/Semantic_Web][Semantic Web]]
   - [[https://en.wikipedia.org/wiki/Semantic_desktop][Semantic desktop]]
   - [[https://en.wikipedia.org/wiki/Quantified_self][Quantified self]]
   - [[https://en.wikipedia.org/wiki/Personal_knowledge_base][Personal knowledge base]]
   - [[https://en.wikipedia.org/wiki/Virtual_folder][Virtual folder]]
   - [[https://en.wikipedia.org/wiki/Faceted_classification][Faceted classification]]
   - [[https://en.wikipedia.org/wiki/Metadata][Metadata]]
   - [[https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model][Entity–attribute–value model]]
   - [[https://en.wikipedia.org/wiki/Adaptive_hypermedia][Adaptive hypermedia]]
   - [[https://en.wikipedia.org/wiki/Hypertext][Hypertext]]
   - [[https://en.wikipedia.org/wiki/Semantic_desktop][Semantic desktop]]
   - [[https://en.wikipedia.org/wiki/Parallel_text][Parallel text]]
   - [[https://en.wikipedia.org/wiki/Transclusion][Transclusion]]
   - [[https://en.wikipedia.org/wiki/Graph_database][Graph database]]
   - [[https://en.wikipedia.org/wiki/Universally_unique_identifier][Universally unique identifier (UUID)]]
   - [[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier][URI]] / [[https://en.wikipedia.org/wiki/Uniform_Resource_Locator][URL]] / [[https://en.wikipedia.org/wiki/Uniform_Resource_Name][URN]]
   - [[https://en.wikipedia.org/wiki/Dublin_Core][Dublin Core]]

** Люди

   - [[https://en.wikipedia.org/wiki/Douglas_Engelbart][Douglas Engelbart]]
   - [[https://en.wikipedia.org/wiki/Vannevar_Bush][Vannevar Bush]]
   - [[https://en.wikipedia.org/wiki/Andries_van_Dam][Andries van Dam]]
   - [[https://en.wikipedia.org/wiki/Ted_Nelson][Ted Nelson]]

** Книги

   История:
   - [[http://www.anthempress.com/memory-machines][Memory Machines: The Evolution of Hypertext]] (Anthem Press)

   Техническое:
   - A Semantic Web Primer (MIT Press)
   - Semantic Web for the Working Ontologist (Morgan-Kaufman)
   - Learning SPARQL (O'Reilly)
   - Graph Databases (O'Reilly)

   Методологическое:
   - Keeping Found Things Found (Morgan-Kaufman)
   - The Discipline of Organizing (MIT Press)
   - Sönke Ahrens -- [[https://takesmartnotes.com/][How to Take Smart Notes]]
   Художественное:
   - Игра в бисер (Герман Гессе)

** Ассоциации

   * [[https://www.asist.org/][Association for Information Science and Technology]]

** Конференции

   * [[https://archive.org/details/PDA2015][Personal Digital Archiving Conference]]

** Прочее

   http://infotoday.com/ – новости

   http://booksblog.infotoday.com/ – книги

   Каталог статей на сайте Брета Виктора: Engelbart, Bush, Alan Key и
   другие - http://worrydream.com/refs/.
